(* ::Package:: *)

(*<<maTHEMEatica`
SetOptions[EvaluationNotebook[], DefaultNewCellStyle->"Code"];
colors = <|
	"background"->RGBColor["#000000"],
	"fontcolor"->RGBColor["#eeeeee"],
	"primary"->RGBColor["#B87333"],
	"variable"->RGBColor["#55f7df"],
	"module"->RGBColor["#e638e9"],
	"block"->RGBColor["#FFFF00"],
	"error"->RGBColor["#FF0000"],
	"headhighlight"->RGBColor["#02584c"]
|>;
SetColors[colors]
CreateStyleSheet[]
ApplyStyleSheet[]*)


(* ::Section:: *)
(*Package Header*)


BeginPackage["FelipeBarbosa`SymDALI`DerivativeTools`"];

DerivativeRules::usage="DerivativeRules[{name, vars, n}, expr] returns a list of Rules where each rule is a possible derivative of expr with respecto to vars, from order 1 to n, 
and the second element is the corresponding pure Function";
CLibraryFunction::usage="returns the LibraryFunction generated by Compile";
SaveSymRules;
SaveNRules;
DerivativeRulesLoad;
$D::usage="$D[{1,2,...}, h][x,y,...] has the same meaning of Derivative[1,2,...][h][x,y,...], its only purpose is to allow more
efficient rule replacement in DALICoefficients and GWDALICoefficients";
$Block;


Begin["`Private`"]


(* ::Section:: *)
(*Definitions*)


Attributes[genErrorMessage] = HoldAll;

genErrorMessage[test_] := Module[
	{message},
	
	message = ToString[Unevaluated[test]];
	
	If[
		test,
		True,
		"The following Conditions were not satisfied: " <> message
	]
] 


DerivativeCombinations[vars_List, n_Integer]/;n>0 := Table[
		(Sort/@Tuples[vars, i])//DeleteDuplicates,
		{i,n}
	]//Flatten[#,1]&;

(*I took this from Shiffrin's answer in: https://mathematica.stackexchange.com/questions/29321/what-are-the-best-practices-most-common-idiomatic-ways-to-report-errors-in-m *)

DerivativeCombinations[args___] := Throw[$Failed, failTag[DerivativeCombinations]]


Attributes[$Block] = {HoldAll};

$Block[{{heads___}, othervars___}, expression___] := Block[{heads, othervars}, expression]


(*
Logic: takes the $Module expression, with heads already changed to unique heads and $Module replaced by Hold,
a specific derivative and the unique heads
it calculates the derivative in terms of the heads 
declared in $Module, without their explict definition.
Ex: h1[x] h2[y] + (x,y) derivative -> h1'[x] h'[y]
*)



(*uniqueheads : {h1$, h2$,...}*)
DerivativeExpression[x_Hold, derivative_List, uniqueheads_List]/;(
	Head/@derivative == ConstantArray[Symbol, Length@derivative] &&
	Head/@uniqueheads == ConstantArray[Symbol, Length@uniqueheads]
):= Module[
	{iheads, iexpr, changeHeads, rhsRule, rule},
	
	rhsRule = ReplaceAt[
		Hold[uniqueheads, D[expr, Sequence@@derivative]],
		List->ClearAll,
		{1,0}
	];
	
	rule = (RuleDelayed[expr_, $$x]/.$$x -> rhsRule)/.Hold-> CompoundExpression;
	
	iexpr = ReplaceAt[
		x,
		rule,
		{-1,-1}
	];
	
	iexpr  = ReplaceAt[iexpr, {$$x___} -> {}, {1,1}];
	
	Quiet[
		Simplify[$Block@@iexpr, TimeConstraint->0.1, ComplexityFunction->ByteCount],
		Simplify::time
	]
]


DerivativeExpression[x___] := Throw[$Failed, failTag[DerivativeExpression]]


(*
	expr: $Block expression with $Block->Hold and unique heads instead of the original ones
	functions: list of function and function derivatives, i.e. {f[x, f'[x], g''[x],...}
	Pool: HashTable DataStructure
	Output: None. It adds the explicit definition of the functions in "functions" to the association, i.e.,
	Pool[f[x]] = x^2; Pool[f'[x]] = 2 x; Pool[g''[x]] = Sin[x]; ...
	
*)

UpdateDefPool[expr_Hold, functions_List,  Pool_DataStructure]/;(Length[functions] >= 1) := Module[
	{ExplicitDefs},
	
	ExplicitDefs = ReplaceAt[
		expr,
		x_ -> functions,
		{-1, -1}
	];
	
	ExplicitDefs = $Block@@ExplicitDefs;
	
	MapThread[
		(Pool["Insert", #1->#2])&,
		{functions, ExplicitDefs}
	];
]



UpdateDefPool[expr_Hold, {}, Pool_DataStructure] := Null;

UpdateDefPool[x___] := Throw[$Failed, failTag[UpdateDefPool]]


(*
	expr: $Block expression with $Block -> Hold and heads replaced by uniqueheads
	DExpression: Expression obtained by applying D[,x__] to the result of $Block
	uniqueheads: heads used in expr
	pool: Association with explicit definitions of some derivatives
	
	Output: list of functions and their definitions, i.e.
		{
			{f[x], f'[x], f''[x],...},
			{x^3, 3 x^2, 6 x, ...}
		}

*)

ExplicitFunctions[expr_Hold, DExpression_, uniqueheads_, pool_DataStructure]/;(
	Head/@uniqueheads == ConstantArray[Symbol, Length@uniqueheads]
) := Module[
	{Dpatterns, headpatterns, heads, Ds, functions, PosOfMissingFuncs, Explicitdefs},
	
	Dpatterns= Derivative[n__][Alternatives@@uniqueheads][args__];
	
	headpatterns = (Alternatives@@uniqueheads)[args__];
	
	heads = Cases[DExpression, headpatterns, Infinity]//DeleteDuplicates;
	Ds = Cases[DExpression, Dpatterns, Infinity]//DeleteDuplicates;
	
	functions = Join[heads,Ds];
	
	(*Update the explicit definitions pool:*)
	
	PosOfMissingFuncs = Position[False]@(pool["KeyExistsQ", #]&/@functions);
	
	UpdateDefPool[expr, Extract[functions, PosOfMissingFuncs], pool];
	
	(*Now we just retrieve the defs:*)
	Explicitdefs = pool["Lookup", #]&/@functions;
	
	{
		functions,
		Quiet[
			Simplify[Explicitdefs, TimeConstraint->0.1, ComplexityFunction->ByteCount],
			Simplify::time
		]
	
	}
]


ExplicitFunctions[x___] := Throw[$Failed, failTag[ExplicitFunctions]]


DFunction[DExpression_, functionDefs_List] := Module[
	{len = Length[functionDefs[[1]]],localVars, rules1, iDExpression, defs, ModuleExpr, expr },
	
	
	localVars = Hold@@ToExpression[
		("$x" <> ToString[#])&/@Range[len],
		InputForm,
		Hold
	]//Flatten; (*Make Hold[$arg1$1,$arg$2,...]*)
	
	
	rules1 = List@@Thread[
		RuleDelayed[Hold@@(functionDefs[[1]]), Evaluate@localVars],
		Hold
	];
	
	iDExpression = Quiet[
		Simplify[DExpression//.rules1, ComplexityFunction->ByteCount, TimeConstraint->0.1],
		Simplify::time
	];
	
	iDExpression = Hold[Evaluate@iDExpression];
	
	defs = Thread[
		set[localVars, Hold@@(functionDefs[[2]])],
		Hold
	];
	
	ModuleExpr = Join[defs, iDExpression]/.set->Set;
	
	ModuleExpr = ReplaceAt[
		Hold[Evaluate@ModuleExpr],
		Hold -> CompoundExpression,
		{1,0}	
	];
	
	localVars = localVars/.Hold[args__] :> Hold[{args}];
	
	ModuleExpr = Join[localVars, ModuleExpr];
	
	
	ModuleExpr = ReplaceAt[
		HoldForm[Evaluate@ModuleExpr],
		Hold -> Block,
		{1,0}
	];
	
	If[
		NumberQ[Identity@@ModuleExpr],
		Identity@@ModuleExpr,
		ModuleExpr
	]
]


Attributes[TakeDerivative] = HoldFirst;

TakeDerivative[expr_, derivative_List, pool_DataStructure]/; (Head[Unevaluated[expr]] == $Block ):= Module[
	{iexpr,heads, uniqueHeads, rules, dexpre, explFuncs},
	(*change the heads in expression for unique heads and $Block -> Hold:*)
	iexpr = Hold@@Unevaluated[expr];
	heads = Map[
		HoldPattern,
		Extract[iexpr, {1,1}, Hold],
		{2}
	]//ReleaseHold;
	
	uniqueHeads = Unique@@(Unevaluated/@Extract[iexpr, {1,1}, Hold]);
	 
	rules = MapThread[Rule, {heads, uniqueHeads}];
	
	iexpr = iexpr//.rules;
	
	dexpre = DerivativeExpression[iexpr, derivative, uniqueHeads];
	
	
	explFuncs = ExplicitFunctions[iexpr, dexpre, uniqueHeads, pool];
	
	DFunction[dexpre, explFuncs]
]

TakeDerivative[args___] := Throw[$Failed, failTag[TakeDerivative]]


Attributes[AuxiliarFunctions] = HoldFirst;

AuxiliarFunctions[expr_, derivativesVars_List]/;(
	(Head@Unevaluated[expr]) =!= $Block

) := Module[
	{derivativesList},
	
	If[
		OptionValue[DerivativeRules, "Parallel"] === {},
		derivativesList = D[expr, Sequence@@#]&/@derivativesVars;,
		LaunchKernels@@OptionValue[DerivativeRules, "Parallel"];
		derivativesList = ParallelMap[D[expr, Sequence@@#]&, derivativesVars];
		CloseKernels[];
	];
	
	
	If[
		OptionValue[DerivativeRules, "IncludeZeroDerivative"],
		PrependTo[derivativesList, expr],
		derivativesList
	]
]



AuxiliarFunctions[expr_, derivativeVars_List]/;(Head@Unevaluated[expr] == $Block) := Module[
	{derivativesList, DefinitionsPool},
	
		DefinitionsPool = CreateDataStructure["HashTable"];
		
		derivativesList = TakeDerivative[expr, #, DefinitionsPool]&/@derivativeVars;
	
	If[
		OptionValue[DerivativeRules, "IncludeZeroDerivative"],
		PrependTo[derivativesList, TakeDerivative[expr, {}, DefinitionsPool]],
		derivativesList
	]
]

AuxiliarFunctions[args___] := Throw[$Failed, failTag[AuxiliarFunctions]]


iDerivativeRules[name_Symbol, vars_List, derivativeVars_List, functions_List] := Module[
	
	{derivativeHeadList, RulesList, patternVars, patternDerivativeVars, rule, nonzeroCases, numberCases, trivialRules},
	
	patternVars = Pattern[#, Blank[]]&/@vars;
	
	patternDerivativeVars = Map[
		Pattern[#, Blank[]]&,
		derivativeVars,
		{2}
	];
	
	(*Include 0 derivative head if necessary*)
	derivativeHeadList = If[
		OptionValue[DerivativeRules, "IncludeZeroDerivative"],
		Prepend[ D[name@@patternVars, Sequence@@#]&/@patternDerivativeVars,  name@@patternVars],
		D[name@@patternVars, Sequence@@#]&/@patternDerivativeVars
	];
	
	derivativeHeadList = Replace[
		derivativeHeadList,
		Derivative[x__][y_Symbol][k__] -> $D[{x},y][k],
		{1}
	];
	
	
	(*Now, finally construct the list of Rules*)
	RulesList = MapThread[
		(#1  -> #2)&,
		{derivativeHeadList, functions}
	];
	
	(*Reorganize such that the output is {{trivialRules}, {rules}}, trivialRules: FunctionDerivative ->NUMBER*)
	numberCases = Position[RulesList[[All, 2]], x_/;NumberQ@x, {1}];
	
	trivialRules = Extract[RulesList, numberCases];
	
	{
	trivialRules, 
	Delete[RulesList, numberCases]
	}
]


iDerivativeRules[args___] := Throw[$Failed, failTag[iDerivativeRules]]


DerivativeRules::fail="The function failed. The failure occured in function `1`";


Attributes[DerivativeRules] = HoldRest;

Options[DerivativeRules] = {"IncludeZeroDerivative" -> True, Assumptions -> $Assumptions, TimeConstraint->300, 
	"Parallel" -> {} };

(*HOW CAN I CONSTRAIN THIS OPTION TO BE EITHER TRUE OR FALSE?*)
DerivativeRules[{name_, vars_, n_}, expr_, OptionsPattern[]]/;(
	genErrorMessage@(
		Comap[{OwnValues, UpValues, SubValues, FormatValues, NValues, DownValues}, name] === ConstantArray[{}, 6]
	) &&
	genErrorMessage@(Head/@{name, vars, n} === {Symbol, List, Integer}) &&
	
	genErrorMessage@(Head/@vars === ConstantArray[Symbol, Length@vars] && n>0) &&
	
	genErrorMessage@(Comap[{OwnValues, DownValues, SubValues, UpValues}, name] === {{},{},{},{}})
	
) := Module[

	{listOfDerivatives, listOfFunctions, listOfRules, zeroCases, trivialRules},
	
	Catch[
		listOfDerivatives = DerivativeCombinations[vars, n];
		listOfFunctions = AuxiliarFunctions[
			expr, 
			listOfDerivatives
		];
		
		listOfRules = iDerivativeRules[name, vars, listOfDerivatives, listOfFunctions];
		listOfRules,
		_failTag,
		(Message[DerivativeRules::fail, Style[First@#2, Red]]; #1) &
	]
]



Options[CLibraryFunction] = {
	CompilationOptions-> Automatic,
	Parallelization -> True,
	RuntimeAttributes -> {Listable},
	RuntimeOptions -> {
		"CatchMachineOverflow" -> False, 
		"CatchMachineIntegerOverflow" -> False, 
		"EvaluateSymbolically" -> False, 
		"RuntimeErrorHandler" -> None,
		"WarningMessages" -> True
	}
};

Attributes[CLibraryFunction] = {HoldRest};


CLibraryFunction[vars_List, expr_, OptionsPattern[]] := Module[
	{optsValues, opts, iexpr = Hold[expr]},
	
	optsValues = OptionValue[CLibraryFunction, #]&/@(Options[CLibraryFunction][[All,1]]);
	
	opts = Hold@@MapThread[
		Rule[#1,#2]&,
		{Options[CLibraryFunction][[All,1]], optsValues}
	];
	
	AppendTo[opts, CompilationTarget->"C"];
	
	(Compile@@Join[Hold[vars],iexpr, opts])[[-1]]
]


(*Tests if the file structure is:
	TheoryName:
		SymRules
		NRules
		Defs.wdx (may or may not exist)
*)

ParentDirectoryTest[directory_] := Module[
	{DirecName, PDirecName, isPDirecNameOk, PDirecContent, isPDirecContentOk, MacOSDefaultFile = ".DS_Store"},
	
	(*Take the Directory, ParentDirectory names*)
	DirecName =  FileNameTake[directory, -1];
	PDirecName = FileNameTake[ParentDirectory[directory], -1];
	
	
	(*test valid PDirecNames:*)
	isPDirecNameOk = StringCases[PDirecName, {"SymRules", "NRules", "Defs"}] === {};
	
	(*Now, test valid content in the PDirec*)
	PDirecContent = FileNameTake[#,-1]&/@FileNames[All, ParentDirectory[directory]];
	
	isPDirecContentOk = (
		Sort[PDirecContent] === {MacOSDefaultFile, "NRules", "SymRules"} ||
		Sort[PDirecContent] === {MacOSDefaultFile, "Defs.wdx", "NRules", "SymRules"}
	  );
	
	And[isPDirecContentOk, isPDirecNameOk]
]


(*Test for contents in SymRules and NRules:
	SymRules:
		.wdx files or empty
	NRules:
		empty
*)

DirectoryFilesTest[directory_] := Module[
	{
	PDirec, PDirecContent, isSymFilesOk, isNFilesOk, MacOSDefaultFile = ".DS_Store"
	},
	
	(*Take the Directory, ParentDirectory, prefix and theoryName *)
	PDirec = ParentDirectory[directory];
	
	
	(*See if the file contents are correct*)
	isSymFilesOk = StringMatchQ[#, {"*.wdx", ".DS_Store"}]&@FileNames[
		All,
		FileNameJoin[PDirec, "SymRules"] 
	]; (*This outputs either a list of true and False, or an empty list*)
		
	(*only True if the list is empty or full with Trues*)	
	isSymFilesOk = And@@isSymFilesOk;
	
	
	(*NFiles has to be empty, bcs I don't know how to change the name of a C function
	inside the file and mathematica uses the same names (CompiledFunction0, CompiledFunction1,...) in different
	kernelSessions, making it impossible to add files to the directory through different kernelSessions.*)
	isNFilesOk = FileNames[
		All, FileNameJoin[PDirec, "NRules"]
		] === {};
	
	
	 And[isSymFilesOk, isNFilesOk]
]	


FullDirectoryTest::fail = "You can only save files in the following directory structure:";


FullDirectoryTest[directory_] := Module[
	{result}, 
	
	result = ParentDirectoryTest[directory] && DirectoryFilesTest[directory];
	
	If[TrueQ@result, True, Throw[Message[FullDirectoryTest::fail]; directoryTree]]
	]


directoryTree = Tree[
	"TheoryName (any name but SymRules, NRules \[And] Defs)", 
	
		{
			Tree["SymRules", {"only .wdx files in this directory"}],
			Tree["NRules",  {"no files in this directory"}], 
			"Optional: Defs.wdx file here"
		
		}
	,
	Background->White
];


iSaveSymRules[{rule_, fileName_String}, directory_] := Export[
	FileNameJoin[directory, FileBaseName[fileName] <> ".wdx"], 
	rule
	];


iSaveNRules[rules_, directory_] := Module[

	{TranslationTable, fileNames, argsforCopyFile},
	
	TranslationTable = Replace[rules, LibraryFunction -> List, {2}, Heads->True];
	
	fileNames = FileNameTake[#, -1]&/@rules[[All, 2, 1]];
	
	argsforCopyFile = Riffle[
		rules[[All, 2, 1]], 
		FileNameJoin[directory, #]&/@fileNames
	]//Partition[#, 2]&;
	
	CopyFile@@@argsforCopyFile;
	
	(*Change the names in TranslationTable, making it easier to import LibraryFunctions:*)
	 Replace[TranslationTable,  Rule@@@argsforCopyFile, {3}]
]


SaveSymRules[{rules_Association, fileName_String}, directory_?DirectoryQ] := Module[
	{},
	
	Catch[
		FullDirectoryTest[directory];
		iSaveSymRules[{rules, fileName}, directory]
	];
]


SaveNRules[rules_Association, directory_?DirectoryQ] := Module[
	{ruleList},
	Catch[
		FullDirectoryTest[directory];
		
		
		ruleList = KeyValueMap[
			Rule[#1, iSaveNRules[#2, directory]]&,
			rules
		];
		
		Export[directory <> "/RosettaStone.wdx", Association@ruleList];
	];
]


ExtractLibraryFunction[x_]/; Head@x === CompiledFunction := x[[-1]]
ExtractLibraryFunction[x_] := x

MakeCompiledFunction[x_LibraryFunction,  expression_, WVM_] := Module[
	{vars =  x[[3, All, 1]], compiledfunction, iexpression = expression},
	
	(*eliminate patterns from expression and convert it to string:*)
	iexpression = ToString[iexpression/. dummy_Pattern :> dummy[[1]]];
	
	(*Put the list of variables into the standard form for CompiledFunction:*)
	vars = Blank/@vars;
	
	compiledfunction = { (*These are the settings for the DefaultOptions of CLibraryFunction*)
		{11, $VersionNumber, 4760},
		vars,
		Sequence@@WVM, (*WVM for the correct number of variables. Apparently it has to match the declared number*)
		Function[{}, Evaluate@iexpression, Listable],
		None,
		x
	};
	
	CompiledFunction@@compiledfunction
]


makeWVM[vars_] := Module[
	{list},
	list  = List@@Compile[Evaluate@vars, Evaluate@(Plus@@vars), CompilationTarget->"WVM"
	];
	list[[3;;6]]
]


libraryFunctionsLoad[RulesList_] := Module[
	{ compiledFunctions, expressions, wvm},
	
	compiledFunctions = LibraryFunctionLoad@@@(RulesList[[All,2]]);
	compiledFunctions = ExtractLibraryFunction/@compiledFunctions;
	
	expressions = RulesList[[All,1]];
	
	wvm = ( (List@@RulesList[[1,1]])/. q_Pattern :>  q[[1]])//makeWVM;
	
	compiledFunctions = MapThread[
		MakeCompiledFunction[#1, #2, wvm]&,
		{compiledFunctions, expressions}
	];
	
	Rule@@@(Riffle[expressions, compiledFunctions]//Partition[#,2]&)
]


DerivativeRulesLoad[theory_String] := Module[
	{Pacletdirectory, SymRulesDirec, NRulesDirec, SymRulesDerivatives, NRulesDerivatives, RosettaStone},
	(*THIS WILL BE A BUG IF YOU HAVE MORE THAN ONE VERSION OF THE PACLET*)
	Pacletdirectory = (PacletFind["FelipeBarbosa/SymDALI"]//Last)["Location"];
	
	SymRulesDirec = FileNameJoin[Pacletdirectory,"DerivativeRules" ,theory, "SymRules"];
	NRulesDirec = FileNameJoin[Pacletdirectory,"DerivativeRules", theory, "NRules"];
	
	SymRulesDerivatives = Flatten@(Import[#]&/@FileNames["*.wdx", SymRulesDirec]);
	SymRulesDerivatives = If[ Length@SymRulesDerivatives===1,  SymRulesDerivatives//Last, SymRulesDerivatives];
	
	
	RosettaStone = Import[NRulesDirec <>"/RosettaStone.wdx"];
	NRulesDerivatives = KeyValueMap[
		Rule[#1, libraryFunctionsLoad[#2]]&,
		RosettaStone
	];
	
	{
		SymRulesDerivatives, 
		Association[NRulesDerivatives] 
	}
]


(* ::Section:: *)
(*Package Footer*)


End[];
EndPackage[];
